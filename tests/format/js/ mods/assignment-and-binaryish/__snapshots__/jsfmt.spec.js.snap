// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`assignment.js format 1`] = `
====================================options=====================================
parsers: ["babel", "flow", "typescript"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
const hostnameRegExp = /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*$/i

const str = path
  // Convert from JavaScript property access notation to JSON pointers,
  // while preserving '..' in paths:
  .replace(/\\.([^./]+)/g, '/$1')
  // Expand array property access notation ([])
  .replace(/\\[['"]?([^'"\\]]*)['"]?\\]/g, '/$1')

const offsetX = win.pageXOffset !== undefined ? win.pageXOffset
  : (doc.documentElement || body.parentNode || body).scrollLeft

const value1 = (
  isSchema(schema) &&
  Object.keys(schema?.forms || {}).length > 1
)

const match = (
  isString(value) &&
  value.match(/^\\s*([+-]?\\d+)\\s*\\/\\s*([+-]?\\d+)\\s*$/)
)

const value2 = (
  this.relate &&
  this.hasOptions && (
    value === null && (
      this.value !== null ||
      this.veryLongDefaultValue !== null
    ) ||
    isReferenceVeryLongCall(this.value)
  )
)

const events1 = this.$events || (this.$events = Object.create(null))

const events2 = this.$events ??= Object.create(null)

const index = this.isTransient
  ? // For transient data, the index is used as the id
    itemId
  : data?.findIndex(
      (item, index) =>
        this.getItemId(sourceSchema, item, index) === itemId
    )

const radioSelectedAttr =
  (isAnyValueSelected &&
    node.getAttribute(radioAttr.toLowerCase()) === radioValue) ||
  (!isAnyValueSelected &&
    values[a].default === true) ||
  a === 0;

=====================================output=====================================
const hostnameRegExp =
  /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*$/i;

const str = path
  // Convert from JavaScript property access notation to JSON pointers,
  // while preserving '..' in paths:
  .replace(/\\.([^./]+)/g, "/$1")
  // Expand array property access notation ([])
  .replace(/\\[['"]?([^'"\\]]*)['"]?\\]/g, "/$1");

const offsetX = (
  win.pageXOffset !== undefined
    ? win.pageXOffset
    : (doc.documentElement || body.parentNode || body).scrollLeft
);

const value1 = (
  isSchema(schema) &&
  Object.keys(schema?.forms || {}).length > 1
);

const match = (
  isString(value) &&
  value.match(/^\\s*([+-]?\\d+)\\s*\\/\\s*([+-]?\\d+)\\s*$/)
);

const value2 = (
  this.relate &&
  this.hasOptions && (
    (
      value === null && (
        this.value !== null ||
        this.veryLongDefaultValue !== null
      )
    ) ||
    isReferenceVeryLongCall(this.value)
  )
);

const events1 = this.$events || (this.$events = Object.create(null));

const events2 = (this.$events ??= Object.create(null));

const index = this.isTransient
  ? // For transient data, the index is used as the id
    itemId
  : data?.findIndex(
      (item, index) => this.getItemId(sourceSchema, item, index) === itemId
    );

const radioSelectedAttr = (
  (
    isAnyValueSelected &&
    node.getAttribute(radioAttr.toLowerCase()) === radioValue
  ) || (
    !isAnyValueSelected &&
    values[a].default === true
  ) ||
  a === 0
);

================================================================================
`;

exports[`binaryish.js format 1`] = `
====================================options=====================================
parsers: ["babel", "flow", "typescript"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
function merge(target, source) {
  if (target && source && target !== source && (
    isArray(target) && isArray(source) ||
    isPlainObject(target) && isPlainObject(source)
  )) {
    // Impl
  }
}

function isNumber(arg) {
  const type = typeof arg
  return (
    type === 'number' ||
    !!arg && type === 'object' && toString.call(arg) === '[object Number]'
  )
}

function isEmpty(arg) {
  return (
    arg == null ||
    isArrayLike(arg) && arg.length === 0 ||
    isObject(arg) && Object.keys(arg).length === 0
  )
}

function binaryConditional1() {
  if (token === '.' || token === '..' && i === 0) {
    // Impl
  }
}

function binaryConditional2() {
  if (
    token === '.' ||
    token === '..' && i === 0
  ) {
    // Impl
  }
}

function isHostname(str) {
  return !!(str && hostnameRegExp.test(str))
}

function isMultipleOf10(value) {
  return (value % 10) === 0
}

function binaryTemplate() {
  return (
    this.isTransient &&
    '<b>Note</b>: the parent still needs to be saved ' +
    'in order to persist this change.'
  )
}

function binaryLargeNumbers() {
  return (
    this.isTransient && (
      11111111111111111111111111111111111111111111111111111111111111111111111 +
      22222222222222222222222222222222222222222222222222222222222222222222222
    )
  )
}

function binaryNesting1() {
  return (
    ['post', 'put', 'patch'].includes(method) && (
      button.getSchemaValue(['resource', 'data']) ||
      button.processedItem
    )
  )
}

function binaryNesting2() {
  return (
    ['post', 'put', 'patch'].includes(method) && (
      // TODO: Use \`handleDataSchema()\` asynchronously here instead, to
      // offer the same amount of possibilities for data loading.
      button.getSchemaValue(['resource', 'data']) ||
      button.processedItem
    )
  )
}

function binaryInBinaryLeft() {
  return (
    // Reason for 42
    42
  ) * 84 + 2
}

=====================================output=====================================
function merge(target, source) {
  if (
    target &&
    source &&
    target !== source && (
      (isArray(target) && isArray(source)) ||
      (isPlainObject(target) && isPlainObject(source))
    )
  ) {
    // Impl
  }
}

function isNumber(arg) {
  const type = typeof arg;
  return (
    type === "number" ||
    (!!arg && type === "object" && toString.call(arg) === "[object Number]")
  );
}

function isEmpty(arg) {
  return (
    arg == null ||
    (isArrayLike(arg) && arg.length === 0) ||
    (isObject(arg) && Object.keys(arg).length === 0)
  );
}

function binaryConditional1() {
  if (token === "." || (token === ".." && i === 0)) {
    // Impl
  }
}

function binaryConditional2() {
  if (
    token === "." ||
    (token === ".." && i === 0)
  ) {
    // Impl
  }
}

function isHostname(str) {
  return !!(str && hostnameRegExp.test(str));
}

function isMultipleOf10(value) {
  return value % 10 === 0;
}

function binaryTemplate() {
  return (
    this.isTransient && (
      "<b>Note</b>: the parent still needs to be saved " +
      "in order to persist this change."
    )
  );
}

function binaryLargeNumbers() {
  return (
    this.isTransient && (
      11111111111111111111111111111111111111111111111111111111111111111111111 +
      22222222222222222222222222222222222222222222222222222222222222222222222
    )
  );
}

function binaryNesting1() {
  return (
    ["post", "put", "patch"].includes(method) && (
      button.getSchemaValue(["resource", "data"]) ||
      button.processedItem
    )
  );
}

function binaryNesting2() {
  return (
    ["post", "put", "patch"].includes(method) && (
      // TODO: Use \`handleDataSchema()\` asynchronously here instead, to
      // offer the same amount of possibilities for data loading.
      button.getSchemaValue(["resource", "data"]) ||
      button.processedItem
    )
  );
}

function binaryInBinaryLeft() {
  return (
    (
      // Reason for 42
      42 *
      84
    ) +
    2
  );
}

================================================================================
`;
